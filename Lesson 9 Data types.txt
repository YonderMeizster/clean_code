1) Общие тезисы: 
- Выполнять преобразования типов понятным, явным образом;

1. result = number1 + number2 + number3 + number4 - result = float(number1 + number2 + number3 + number4)
// Питон неявно приведет все слагаемые к наиболее точному типу, в
случае, если какое- то из слагаемых является числом с плавающей точкой,
сумма также будет с плавающей точкой. Вообще- то эта ситуация плоха тем,
что не детерминируема со стороны разработчика. Естественно, разработчик
будет знать, какой тип будет у суммы, но только если он знает, какие
о типах слагаемых. На отрезке жизни системы это превращается почти
в генератор случайных чисел. Если далее в коде, допустим, сумма
используется для форматирования строк, жди беды:

'%i' % 2 -> '2'
'%i' % 2.5 -> '2'

- Избегать сравнения значений разных типов;

2. Данная рекомендация носит интересный характер.
Базово- должна возникнуть достаточно интересная ситуация, чтобы
появилось желание сравнивать, к примеру, строки и числа. А вот при
погружении в полиморфизм можно хорошо навороить. Например, написать пару
собственных типов, в которых переопределить операторы сравнения хитрым
образом: пусть сравнивают сумму атрибутов экзмепляров, ну вот, вдруг
такая потребность возникла. Отлично, получилось уже что- то страшное, но
может быть еще все хуже. Это все будет использоваться на уровнях выше,
где будут сравниваться объекты классов Human и Vehicle (Human и Vehicle
унаследованы от базового класса MovingObject, в котором и переопределен
оператор сравнения, он сравнвиает скорост объектов) и вот, уже вполне
законно и не приходя в сознание можно написать работающий код, которые
сравнивает Human и Vehicle и говорит, что Vehicle больше. Вместо этого
на порядок лучше поступить иным образом: взять аттрибут скорости у двух
объектов и сравнить его значение. Это не создает никакой
неопределенности, а помимо этого тоже не заставляет приходить в
сознание :-)

- Фиксить предупреждения компилятора или статического анализатора;
- Обрабатывать ситуацию деления на 0.

3. Ситуацию деления на 0 вполне можно заключать в try - except
ZeroDivisionError (если рассуждать в рамках python). При разработке
графического интерфейса- еще лучше включить обработку такой ситуации при
валидации формы ввода.

2) Целые числа:
- Помнить о возможном переполнении как в итоговом результате, так и при
промежуточых вычислениях.

4. Я пользуюсь питоном и с ухмылкой смотрю на проблему переполнения. И
зря я так поступаю. Есть тонкий момент: стандартная библиотека питона
защищена от переполнений и позволяет не задумываться об этом вплоть до
решения задачи подсчета числа молекул в обозримой Вселенной. А вот
сторонние библиотеки могут быть не защищены от такого. По найденной мной
информации типы таких библиотек как numpy и pandas могут переполняться,
так что при работе с ними стоит не забывать о таком моменте и уяснить
его для предотвращения сложно отловимой ошибки.

Если даже самый большой тип из стандартной не
позволяет решить проблему переполнения- вполне вероятно, что алгоритм
далеко не оптимальный.

3) Вещественные числа:
- Избегать сложения и вычитания слишком разных по величине чисел;
- Избегать сравнения на равенство; (Использовать сравнение разницы с
достаточно маленьким числом.

5. 0.1 + 0.1 + 0.1 == 0.3 - (0.1 + 0.1 + 0.1 - 0.3) < 0.0000001 //
Проблема с числами с плавающей точкой в компутере аналогична проблеме
человеческой, десятичной системы счисления. В десятичной системе 1/3
записать получится только с периодом. Для двоичной системы десятичная
дробь 0.1 являет собой схожую проблему.

- Предупреждать и учитывать ошибки округления.

6. 
>>> round(1.45, 1)
1.4
>>> round(1.55, 1)
1.6

Питон округляет в сторону четного. Об этом стоит помнить.

- Увеличивать точность при работе с вещественным числами. Например, если
все числа в рассчетах имеют лишь по одному разряду после запятой,
следует увеличить точность до двух знаков после запятой;
- Если значение в переменной с типом с плавающей точкой можно без потери
точности представить в целочисленном типе- так и надо поступать;
- Проверять поддержку специальных типов данных в языке и дополнительных
библиотеках.

7. Для упрощения работы с вещественными числами стандартная библиотека
питона предлагает как минимум два решения: Decimal и Fractions:
0.1 + 0.1 + 0.1 == 0.3 - Decimal('0.1') + Decimal('0.1') + Decimal('0.1') == Decimal('0.3')
// Использование Decimal позволило добиться достаточной точности при
вычислении.

4) Строки и символы:
- Константы помещать в переменные;

8. 3.1415 - math.pi // можно поступать и так, если для этого
возможность. В ином случае PI = 3.1415

9. f"Добро пожаловать в семью, {user.username}" - greetings_to_user = "Добро пожаловать в семью, {}"
// Далее по коду открыватся возможность переиспользования одного и того
же шаблона.

- Использовать Uniocode;
- Закладывать в систему на раннем этапе возможность для
интернационализации программы;

10. Самое банальное- вместо того, чтобы выводить пользователю
фиксированную строку- выводить строку, которая берется с учетом
выбранной локализации. Естественно, в таком случае необходимо продумать
способ организации хранилища, чтобы иметь возможность добавлять новые
локализации в программу);

- Использовать единый способ трансляции строк в разные кодировки, если
так уж получилось.

11. 'test_string'.encode('ASCII') // к примеру, можно использовать такой
вариант перевода в иные кодировки

5) Логические переменные:
- Логические переменные стоит применять для упрощения сложных логических
условий;

12.
if (parcel.is_sent and not parcel.is_delivered) - parcel_on_delivery = parcel.is_sent and not parcel.is_delivered
// заключил логическое выражение в рамках переменной, внеся
дополнительую ясность в код и открыв возможность использовать переменную
далее в коде

