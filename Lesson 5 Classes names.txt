1) Имена классов должны быть существительными или их сочетанием, отражать смысл сущности, которая заложена в этот класс

	1. CollegeTrainee - Student // 
	2. SendToUsersDB - DBInterface // а уже при создании экземпляра стоит указать, интерфейсом для какой базы данных данный объект является. Например users_db_interface
	3. ManageConnections - ConnectionBroker // данный пример демонстрирует, как меняется восприятие при смене названия. Класс под названием 'Управлять соединениями' не говорит ничего внятного читателю кода. ConnectionBroker же, напротив, является распространенным термином.
	4. DropLinkToNode - LinkToNode // в этой примере я хочу продемострировать то, что само по себе "соединение с неким узлом" уже является сущностью. Создания отдельного класса, пускай, даже с несколькими методами, отвечающего за закрытие соединения без неожиданных последствий, не целесообразно. Намного правильнее определить место механизму разрыва соедения внутри класса LinkToNode с помощью вызова дерева методов.
	5. GreetingsToUser - NewUserInitializer // Класс берет на себя ответственность по регистрации нового пользователя в системе. Название отдаленно намекает на его предназначение, но новое название ясно дает понять, что объект данного класса может каким- то образом взаимодействовать с новым пользователем системы.

2) Не надо плодить сущностей сверх необходимого. Данное правило относится не только к иерархии классов, но также и к названиям методов. Если в одном месте проекта пользователь запрашивается методом get_user(), а в другом fetch_user(). То код точно нуждается в рефакторинге. Помимо этого, если эти два метода к тому же имеют, например, одинаковую реализацию или находятся в +- похожих классах, то это верный признак для рассмотрения возможности применения наследования. Но, пожалуй, стоит оставить эти размышления для другого конспекта.

Хорошей демонстрацией этого принципа служит стандартная библиотека многих языков, к примеру, python. Классы, которые поддерживают протокол итерации, обязательно реализуют метод, который вернет итератор: __iter__. Название этого метода остается неизменным во всем коде python. (Скорее всего, это связанно с тем, что классы унаследованы базового класса, который имеет такой метод, но сути дела это не меняет.)

	1. move_right(distance) - move(direction, distance) // Наличие метода move_right говорит о том, что наверняка найдется еще как минимум три метода с почти такой же реализацией. Замена этого метода и методов со схожей идеей на один единственный метод move позволяет избавиться от множества переизбытка сущностей, связанных с движением.
	2. hit_enemy(), hit_target() - hit_target() // Оригинальные методы делают одно и то же, их можно без проблем объединить в один метод.
	3. ConnectionTCP.send_tcp(), ConnectionUDP.send_via_udp() - send() // Абстрактно методы делают одно и то же, просто один пользуется протоколом TCP, другой UDP. Но один почему- то имеет 'via' по середине. Два названия можно объединить в одно send.
	4. pop_user() - get_user() // Оригинальный метод "дергал" информацию о пользователе из списка. Проблема заключается в том, что метод pop() на слуху и он удаляет запрашиваемый элемент из коллекции, из того же самого списка, к примеру. Поэтому его использование не целесообразно и вносит путаницу.
	5. save_data(), backup() - serialize() // Методы сериализуют данные. Да, разные данные своих классов, но должны называться одинаково в рамках проекта.
	6. db_connector, db_intrerface - db_interface // в разных местах кода создаются объекты с одинаковой целью, но называются по- разному. Это вносит путаницу.
	7. connection, connection_tcp - connection // нет смысла в одном месте определять переменную как connection, а в другом добавлять ей постфикс.
	