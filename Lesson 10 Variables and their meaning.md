# Переменные. А также их значение.
## 1. Переменные должны быть явно объявлены.

Объявлением переменной называется процесс выделения необходимого объема памяти
для переменной. Соответственно, для этого необходимо, чтобы компилятор знал тип
переменной, чтобы знать о том, какой объем памяти необходимо выделить для
переменной.
```
- int x;
- float y;
```
Неявное объявление переменных- крайне опасная возможность языка. В Python
используется только лишь неявное объявление.

***
Пример 1.

Помимо того, что в питоне реализовано исключительно неявное объявление
переменных, в нем, помимо этого, еще и есть такая встроенная функция как
setattr(). На первый взгляд она похожа на исщадие Ада. Рискну предположить, что
разработчики CPython более компетенты, нежели я. Поэтому осуждать их не стану,
видимо, есть причины, почему до сих пор эта функция существует. Простому
разработчику остается лишь держать в уме, что у объекта внезапно может появиться
дополнительный аттрибут, который создался из другого потока через setattr().

Пример 2.
В условиях питона возникают некоторые сложности с этим делом при отладке.
Достаточная документация по методам- функциям могла бы решить эти проблемы.
Иногда встречаются монстры, иначе эти возвращаемые значения обозвать нельзя.
Документация, а точнее, 5-6 строк в кавычках после определения функции могла бы
избавить от многих проблем будущих программистов. Самое банальное- написать,
какой тип функция намеревается вернуть. Более продвинутым вариантом может стать
описание сущности, которая возвращается.
***

## 2. Каждую переменную необходимо инициализировать.

В Паскале, на сколько я помню, существует практика объявления и инициализации
переменных в самом начале кодового файла. Это плохо и не надо так делать.

Инициализировать переменную следует либо во время объявления, либо там, где она
используется в первый раз.

В идеале необходимо объявлять и определять переменные непосредственно перед
первым обращением к ним.

В конструкторе класса следует инициализировать все его поля.

***
Пример 3.

Вот так плохо:
```
filtered_values = []
...code...
for value in values:
    filtered_values.append(value)
```
Вот так значительно лучше:
```
...code...
filtered_values = []
for value in values:
    filtered_values.append(value)
```

Пример 4.

Не стоит определять переменную вдалеке от её использования:
```
min_value = sorted(a)[0]
...code...
if min_value < another_value_wich_I_have_been_able_to_imagine
```
Далее приведен исправленный пример:
```
...code...
min_value = sorted(a)[0]
if min_value < another_value_wich_I_have_been_able_to_imagine
```

Пример 5.
```
class Dog():
    def __init__(self):
        self.legs_count = 4

    def bark(self):
        self.voice = 'Лай.mp3'
```
Это никуда не годится, поле voice следует переместить в конструктор.
```
class Dog():
    def __init__(self):
        self.legs_count = 4
        self.voice = 'Лай.mp3'
```
***

## 3. Завершение работы с переменными

При завершении работы с переменной- следует присвоить ей недопустимое значение,
к примеру Null.

***
Пример 6.

В реализации односвязного списка, удаление элемента производится путем
приравнивания к None ссылок, ведущих на этот элемент. В дополнение к этому
следует и само значение элемента приравнивать к None.

```
curr_node.value = None
```
Пример 7.

Поработал с бд - отпусти:

```
connection = None
```
Пример X.

Поработал с переданной переменной из вне, поддерживающей изменение на месте -
опусти её:

```
list_value = None
```
Шутка, так делать не надо :-)

Пример 8.

Имеем многопоточный конвейер по обработке логов и пул, куда эти логи
складываются. Добавим в логи флаг, который говорит, уже обработано логовое
сообщение, или еще нет. А в обработчиках логов будем это самое дельце и
проверять. 

Пример 9.
Данная рекомендация отлично смотрится при применении цикла while:
```
count = 0
while count < max:
    ...code...
```

Исправленный код хорошо смотрелся в условиях, если переменная- аккумулятор count
имеет название, похожее на другую переменную. Это потенциально дает возможность
ошибиться.

```
count = 0
while count < max:
    ...code...
count = None
```
***

## 4. Циклы

Переменную- счетчик для цикла необходимо инициализировать непосредственно рядом
с телом цикла. А также нельзя использовать эту переменную за пределами цикла.

***
Пример 10.

Это является ужасной практикой:
```
count = 0
.
.
.
while count < max:
    ...code...
```
Вместо этого определим переменную непосредственно рядом с циклом:

```
.
.
.
count = 0
while count < max:
    ...code...
```
***
Пример 11.

Может возникнуть соблазн использовать одну и ту же переменную в нескольких
циклах while:
```
i = 0
while i < len(line):
    ...code...

while i >= 0:
    ...code...
```
Как говорил дядюшка Боб: "Такой код дурно пахнет". Чтобы исправить это,
необходимо использовать две переменные. Или заново определять перменную i
перед телом второго цикла:
```
i = 0
while i < len(line):
    ...code...

i = len(line) - 1
while i >= 0:
    ...code...
```
***

## 5. Использование инвариантов и ассертов

Хорошей практикой считается введение в программу отладочного код для тестирования
допустимости значений важных переменных

***
Пример 12.
Прежде, чем возвращать пользователю класса значение, можно проверить
корректность этого значения:

```
assert result >= 0
return result
```
***

**Инвариант** - это свойство математического объекта, или нескольких объектов.
Отражает способность оставаться неизменным в результате некоторых операций.

Соответственно, инвариант класса определяет возможность объектам этого класса
оставаться даже не столько неизменными, сколько находиться в допустимых пределах
своих значений. К примеру:

***
Пример 13.

Класс Car имеет аттрибут скорость. И в результате операций, скорость
объекта Car может стать отрицательной.

Введем инвариантность: добавим функцию, проверяющую, что скорость находится в
пределах от 0 до скорости света. А саму эту функцию будем вызывать после
воздействия на объект через публичные методы.

Пример 14. 

При взаимодействии с rsyslog приходится работать со стандартом
rfc5424. Данный стандарт описывает структуру логовых сообщений, назначение полей
внутри них, а также возможные значения, например, какое поле должно быть в
ASCII, а какое в UTF-8.

Моя реализация обработчика логов принимает сообщения из стороннего кода, крутит-
вертит и отправляет в кластер хранения логов.

На стороне кластера происходит парсинг полученных логов. И устроен он так, что в
случае несоблюдения формата, изложенного в rfc5424, лог может и вовсе не
сохраниться.

Чтобы защититься от этой ситуации я сделал следующее:
Перед отправкой лога я проверяю, что он имеет корректный формат, а также
проверяю его поля на кодировки и запрещенные к передаче символы. Задачку с
проверкой экранирования я пока еще не решил, но в процессе. И если, лог не
проходит проверку- я добавляю к нему запись о том, что лог может быть
неправильно сохранен в БД. А входные параметры в функцию я складирую в файлик,
по которому можно понять, что сломало функцию.

Пример 15.
```
self.first_number = first_number
self.second_number = second_number
```
Оригинальный код никак не реагировал на возможное деление на 0. Ассерт помог
справиться с этой проблемой
```
self.num1 = first_number
self.num2 = second_number
assert num2 != 0, "The divisor is zero"
```
