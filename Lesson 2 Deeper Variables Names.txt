6.1) Учитывать абстракции в отношении переменных

1. weight_kg - weight // В гипотетическом классе Person есть
гипотетическая пременная weight_kg. Её следует поднять на уровень
абстракции выше, переименовав в weight. Тем самым смысл не теряется, а
переменная может так же использоваться в проектах, где в неё будет
помещено значение не в килограммах, а например, в фунтах.

2. id - evaluated_hash // В одной из функций подсчета контролльной суммы
я увеличиваю значение переменной id на некие значения. В рамках класса,
я использую эту функцию, чтобы получить идентификатор слота, в который
положу значение, но в рамках функции нет никакого слота, единственная
ответственность функции- посчитать хэш. Поэтому такую локально
используемую функцию стоит назвать по- другому (можно было бы обозвать
и просто hash, но возникает конфликт имен со стандартной библиотекой).

3. array_of_numbers - numbers // Это пример из стороннего проекта. В
данном случае оригинальное название переменной является крайне
приближенной абстракцией, потому что array, а также неверной, потому
что в переменной хранится list.

4. humans - unpaided_workers // Сотрудники, не получившие зарплату.
С одной стороны такое переименование позволяет добавить контекста, с 
другой стороны сразу становится понятно, что workers- работники, а не
"общепринятый стандарт человека" во множественном количестве.

5. summed_values - summed_lists_values // переменная используется в
функции по сложению двух односвязных списков моей реализации. Переход 
более нижний уровень абстракции позволяет расскрыть то, что в переменной
хранится не, так сказать, "конкатенаци" списоков, а именно, что сумма
значений двух списков. Уточнение о том, что переменная является таким
же односвязным списком не требуется по причине того, что ей явно 
присваивается экземпляр односвязного списка из конструктора.

6.2) Применять распространенные технические термины или термины из
контекста проекта

1. В программе, используещей несколько методов шифрования, я бы сохранял
результат шифрования в переменные с обозначением методов. Например:
шифротексту, полученному по методу rot13, я бы приравнял переменную с
названием cyphered_by_rot13.

2. Переменной rdp_connection я бы присвоил экземпляр remote desktop
protocol соединения.

3. Для объекта, представляющего пользователя с повышенными привелегиями,
я бы использовал переменную maintenance_programmer внутри проекта своей
компании. Название переменной слегка выходит за рекомендуемый предел
допустимой длины, но зато любому работнику фирмы, даже не разработчику,
ясно, что обозначает данная переменная.

4. Переменную connection_string я бы приравнял к значению строки
подключения к базе данных.

6.3) Дополнять имена переменных контекстом, в котором они имеют смысл

1. decimal_color_level // Данная переменная хранит десятичное значение
уровня одного из каналов RGB. В обрамляющую функцию поступает объект
RGB, из чего следует, что decimal_color_level хранит значение одного
из цветов.

2. visited_slots // Переменная используется в функции, в которой
я отслеживаю слоты, по которым прохожусь в цикле. Что за slots ясно по-
причине того, что во всем классе ведется работа с этой абстркцией.

3. keys // В моей реализации словаря эта переменная хранит коллекцию
ключей. Что за keys становится понятно из контекста класса.

6.4) Удерживать длину переменных в пределах 8-20 символов
(10- 16 еще лучше).

1. distance_between_cities - cities_distance // Оригинальная переменная
слишком длинная. Можно укоротить без потери смысла

2. find_repeated_odd_number - repeated_odds_number // Тут уже название
функции, но не смог пройти мимо, оно перегружено словом find, от
которого можно безболезненно избавиться.

3. first_encountered_odd_number - first_odd_number // Смысл не теряется,
но название укорачивается

4. time_elapsed_between_page_load_and_form_submission -
load_to_submit_time // Нашел оригинальный код на гитхабе, от сокращения
смысл не теряется.

5. average_rating_by_users - avg_users_rating // Смысл не исказился от
сокращения.
