# А сколько должны жить переменные?
## 1) Маленькая область видимости ведет к появлению меньшего числа ошибок

При объявлении переменных всегда следует выделять им наименее возможную область
видимости.
Автор книги Объекто- ориентированный подход, некто Мэтт Вайсфельд, рекомендует
руководствоваться следующим принципом:

> Все переменные и методы класса должны быть приватными. Давать к ним доступ из
> вне класса нужно лишь в тот момент, когда иного выхода нет.

Цитата не до конца точна, но смысл передан верно.
К объявлению глобальных переменных и вовсе стоит приходить в последнюю очередь.

Авторство приведенной ниже цитаты принадлежит уже другому персонажу, некому Денису:

>**Отстоим позиции за права на частную жизнь переменных!**

## 2) Обращения к переменной должны тесниться. Или "В тесноте - да не в обиде"

Собственно говоря, данная рекомендация появляется из практики жизни: эффективнее
всего получается то дело, которое выполняется без отвлечения.

Конечно, читатель может обвинить меня в том, что мое сравнение основано на том,
что я "высосал" этот пример из пальца. Я не рискну спорить с этим читателем.
Потому что я согласен :-)

Куски кода, разграничивающие обращения к переменной ведут к увеличению рисков.
Чем больше эти куски- тем больше вероятность появления кода, изменяющего
переменную по- середине. В данном случае автор берет на себя ответственность
расценивать других разработчиков так, словно это жизненные обстоятельства,
проявляющие себя в хаотическом порядке.

Красивым методом следования этой рекомендации является использование переменной
лишь внутри относительно небольших методов и отсутствие её использования в иных
местах кода.

***
## Мои размышления по теме и примеры исправленного кода

1\.  Использование глобальной переменной в классе из библиотеки, отвечающей за логгирование.

Имеем глобальную переменную, хранящую путь до файла, куда складируем логи:
```
log_storage_path = ''
```

- Первый вопрос: что произойдет, если библиотека станет использоваться в других
продуктах? А там может быть потребность даже не в том, чтобы по другому пути
хранить логи, сколько может быть потребность использовать библиотеку в другой
ОС.
- Второй вопрос: как этой библиотекой пользоваться в двух компонентах продукта?
Они ж будут в одно и то же место прикапывать журналируемые события.

Это необходимо срочно исправлять:

    1) Переменную запихнуть непосредственно в место складирования логов. Желательно, в класс,
    который и производит складирование;

    2) Значение переменной задавать из конфига, а также внедрить проверку этого
   значения. Естественно, не давать стартовать продукт, пока пользователь не
   разрешит проблему с тем, что его журналируемые события никуда не
   складируются.

***

2\. Класс Human

name = 'Jonnny Depp' - self.name = name // Всех называли Jonnny Depp, теперь имя
передавалось в конструкторе, это позволило повысить качество user-experience

***

3\. Функция, приветствующая пользователя, принимает в себя текст приветствия,
определенный далеко в антиконце кода.
greeting = 'Привет пользователь'
...code...
say_hello_user(greeting)

Такое никуда не годится. Поправим:

...code...
greeting = 'Привет пользователь'
say_hello_user(greeting)

4\. r при своем первом появлении хранила request от http сервера. Потом в неё
насильно и без разрешения запихнули 0 и она стала аккумулятором для while.

Разрешим ситуацию следующим образом: в r оставим реквест, а потом и удалим её
через del. Если весь метод гораздо больше того куска кода, в котором в последний
раз встретилась r- стоит призадуматься, а правильно ли вообще метод написан.
Возможно, ему требуется дифференциация.

На самом деле я не вижу никакого смысла использования del в этом примере потому
что наверняка из метода можно выделить кусок с обработкой ответа r в отдельный
метод. А там уж с r разберется сборщик мусора после того, как метод будет снят
со стека. А для цикла while заведем новую переменую по имени i.

***

5\. Клиентское ПО, которое обращается за прогнозом погоды

Почему- то ПО всегда считает, что оно в Аргентине:
```
we_in_country = 'Argentina'
```

Не стоит дожидаться, пока везде настанет Аргентина, а вместо это будем
запрашивать локацию и передавать через конструктор:

```
self.we_in_country = we_in_country
```

6\. Всегда происходит что- то жуткое, когда так и оставляешь задание без решения
на полусло
