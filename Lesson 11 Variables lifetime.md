# А сколько должны жить переменные?
## 1) Маленькая область видимости ведет к появлению меньшего числа ошибок

При объявлении переменных всегда следует выделять им наименее возможную область
видимости.
Автор книги Объекто- ориентированный подход, некто Мэтт Вайсфельд, рекомендует
руководствоваться следующим принципом:

> Все переменные и методы класса должны быть приватными. Давать к ним доступ из
> вне класса нужно лишь в тот момент, когда иного выхода нет.

Цитата не до конца точна, но смысл передан верно.
К объявлению глобальных переменных и вовсе стоит приходить в последнюю очередь.

Авторство приведенной ниже цитаты принадлежит уже другому персонажу, некому Денису:

>**Отстоим позиции за права на частную жизнь переменных!**

## 2) Обращения к переменной должны тесниться. Или "В тесноте - да не в обиде"

Собственно говоря, данная рекомендация появляется из практики жизни: эффективнее
всего получается то дело, которое выполняется без отвлечения.

Конечно, читатель может обвинить меня в том, что мое сравнение основано на том,
что я "высосал" этот пример из пальца. Я не рискну спорить с этим читателем.
Потому что я согласен :-)

Куски кода, разграничивающие обращения к переменной ведут к увеличению рисков.
Чем больше эти куски- тем больше вероятность появления кода, изменяющего
переменную по- середине. В данном случае автор берет на себя ответственность
расценивать других разработчиков так, словно это жизненные обстоятельства,
проявляющие себя в хаотическом порядке.

Красивым методом следования этой рекомендации является использование переменной
лишь внутри относительно небольших методов и отсутствие её использования в иных
местах кода.

***
## Мои размышления по теме и примеры исправленного кода

1\.  Использование глобальной переменной в классе из библиотеки, отвечающей за логгирование.

Имеем глобальную переменную, хранящую путь до файла, куда складируем логи:
```
log_storage_path = ''
```

- Первый вопрос: что произойдет, если библиотека станет использоваться в других
продуктах? А там может быть потребность даже не в том, чтобы по другому пути
хранить логи, сколько может быть потребность использовать библиотеку в другой
ОС.
- Второй вопрос: как этой библиотекой пользоваться в двух компонентах продукта?
Они ж будут в одно и то же место прикапывать журналируемые события.

Это необходимо срочно исправлять:

    1) Переменную запихнуть непосредственно в место складирования логов. Желательно, в класс,
    который и производит складирование;

    2) Значение переменной задавать из конфига, а также внедрить проверку этого
   значения. Естественно, не давать стартовать продукт, пока пользователь не
   разрешит проблему с тем, что его журналируемые события никуда не
   складируются.

***

2\. Класс Human.

name = 'Jonnny Depp' - self.name = name // Всех называли Jonnny Depp, теперь имя
передавалось в конструкторе, это позволило повысить качество user-experience

***

3\. Функция, приветствующая пользователя, принимает в себя текст приветствия,
определенный далеко в антиконце кода.
greeting = 'Привет пользователь'
...code...
say_hello_user(greeting)

Такое никуда не годится. Поправим:

...code...
greeting = 'Привет пользователь'
say_hello_user(greeting)

4\. r при своем первом появлении хранила request от http сервера. Потом в неё
насильно и без разрешения запихнули 0 и она стала аккумулятором для while.

Разрешим ситуацию следующим образом: в r оставим реквест, а потом и удалим её
через del. Если весь метод гораздо больше того куска кода, в котором в последний
раз встретилась r- стоит призадуматься, а правильно ли вообще метод написан.
Возможно, ему требуется дифференциация.

На самом деле я не вижу никакого смысла использования del в этом примере потому
что наверняка из метода можно выделить кусок с обработкой ответа r в отдельный
метод. А там уж с r разберется сборщик мусора после того, как метод будет снят
со стека. А для цикла while заведем новую переменую по имени i.

***

5\. Клиентское ПО, которое обращается за прогнозом погоды.

Почему- то ПО всегда считает, что оно в Аргентине:
```
we_in_country = 'Argentina'
```

Не стоит дожидаться, пока везде настанет Аргентина, а вместо это будем
запрашивать локацию и передавать через конструктор:

```
self.we_in_country = we_in_country
```

6\. Модуль содержит множество классов игровых существ. У всех существ есть один и тот же метод,
печатающий приветствие.

За материалами приветствия они все обращаются в глобальную переменную модуля. Это выглядит
некрасиво. Решением предстает построении иерархии классов. То есть создание базового класса с полем,
содержащим как раз это приветственное сообщение. А все остальные классы унаследовать от него.

7\. ПО запрашивает у пользователя ввода в консоль. Лишь спустя пару десятков строк оно оначинает
обрабатывать пользовательский ввод.

Решение этой ситуации банально- перенести запрос ввода ближе к месту его обработки.

8.\ В функцию поступает число, функция вызывает ряд других функций.
```
estimate(number):
    func1()
    func2()
    func3()
    func4(number)
```
-
```
estimate(number):
    func4(number)
    func1()
    func2()
    func3()
```
Уменьшил объем кода, предшествующий первому использованию кода.

9\. В классе, представляющем узлы в односвязном списке следует сделать поля приватными:
```
self.value - self._value // снизить область видимости пременной полуичлось без последствий
```

10\. В классе, представляющем хэш таблицу "скрыл" от внешнего кода аттрибут, хранящий список.

```
self.slots - self._slots // снизить область видимости пременной полуичлось без последствий
```

11\. В классе хэш- таблице сокрыл и функцию, вычисляющую хэш. С одной стороны такое действие может
усложнить жизнь злоумышленникам (напомню читателю, моя функция на питоне реализована, в гите лежит),
с другой стороны усложняет жизнь пользователям класса. Самое базовое- не известно, на сколько
эффективно функция работает.

12\. GIOB - global input- output buffer, глобальная переменная, используется в десятках функций в
проекте, в неё заносятся значение, а время от времени еще и забираются, для передачи их в поток
вывода.

13\. Исправил 