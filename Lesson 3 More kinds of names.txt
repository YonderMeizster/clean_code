7.1) Булевые переменные лучше именовать как вопрос: is___. Но не всегда,
if ispositive - плохо. А также они должны "утверждать"

1. is_enemy_in_area - enemy_in_area // исправленный вариант короче,
и выглядит лучше внутри условия засчет того, что является утверждением:
if enemy_in_area ("если враг в зоне", вместо дословного "если а враг
в зоне?").

2. _check_array(array, symbol) - _only_symbols_in_array(array, symbol) //
оригинал я нашел в одном из репозиториев. Метод возвращает True если
список array состоит только из symbol.

3. check_winner(self, symbol) - first_player_wins(self, symbol) //
метод возвращает True, если первый игрок победил. Имеет смысл так и
обозвать метод.

4. move - move_is_correct // переменная хранит допустимость сделанного
хода в реализации игры Крестики - нолики.

5. len(expression) - expression_not_empty // В найденном коде
калькулятора в пяти местах вычисляется одно и то же значение длины
expression. Если оно больше нуля- программа падает в недра if'ов.
Пускай реализация остается такой, но стоит все таки занести результат
один раз в переменную и использовать далее её.

7.2) Использовать стандартные имена для булевских переменных

1. taskDone возможно использовать для отслеживания готовности
выполнения task'а в C#.

2. В качестве средства контроля за потоками в этом "приложении" я
воспользовался переменной со стандартным названием done.

done = False

def print_time():
    global done
    while True:
        if done is True:
            print(f"Current time: {time.ctime()}")
            time.sleep(1)
            done = False

def get_input():
    global done
    while True:
        user_input = input("Enter something: ")
        print("\nYou entered: ", user_input)
        done = True

Остается только запустить две функции в разных потоках. Поток с функцией
print_time будет отслеживать значение done и выводить в консоль время
после того, как второй поток закончит свои действия.

7.3) Использовать однобуквенные переменные в циклах только в крайних
случаях

1. for i in numbers - for number in numbers // если цикл достаточно
большой- такое изменение повлечет за собой ощутимое улучшение читаемости
кода, так как он станет более приближен к человеческой речи.

7.4) Использовать антонимы там, где это возможно

1. head - tail // Являются антонимами в моей реализации односвязного
списка.

2. first_encounted - last_encounted // пример использования антонимов 
мной для обозначения первого и последнего встреченных значений.

7.5) Если от временных переменных нельзя избавиться- стоит задуматься о
том, чтобы дать им осмысленное название.

1. processed_number - summed_digits // я использовал оригинальное
название переменной в рекурсивной функции, которая вычисляет цифровой
корень поступившего на вход числа.

2.  Приведенная ниже функция может послужить отличным примером
избавления от временных переменных.

def disemvowel(str2handle):
    vowel_character = ["a", "A", "e", "E", "o", "O", "i", "I", "u", "U"]
    str2return = ""
    i = 0
    n = len(str2handle)
    while i < n:
        if not str2handle[i] in vowel_character:
            str2return += str2handle[i]
        i += 1
    return str2return

Переменные str2return, i, n совсем не нужны. Вот так выглядит функция
после рефакторинга:

def disemvowel(str2handle):
    vowels = ["a", "A", "e", "E", "o", "O", "i", "I", "u", "U"]
    return ''.join([letter for letter in str2handle if letter in vowels])