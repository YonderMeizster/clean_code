# Массивы
## Что с ними делать?
Помимо рекомендаций о том, что стоит проверять границы массивов, а также думать
при использовании их, следует отметить следующее:

> От произвольного доступа к массивам лучше вовсе отказаться.

Произвольная индексация сродни оператору goto. Ведь так и есть: обращение к
произвольному элементу массива заставляет читателя кода держать в своем
килобайте оперативной памяти информацию о том, что и на каких индексах хранится
в массиве.

Вместо массивов можно применять словари, увеличивающие выразительность в коде.
Можно применять и стеки, и очереди, односвязные и двусвязные списки, да все, что
угодно.

В случае, же, если от массива не избавиться- наверняка можно избавиться от
произвольной индексации, к примеру, через использование цикла без индексации.

***

1) Хранение параметров из конфига после парсинга осуществлялось в питоновском
   списке, а мы так опа, и запхнем это все в словарь. А дальше по коду получаем
   возможность обращаться к ним следующим образом: parameters['connection
   string'], а не parameters[2].

2) for i in range(len(some_list) - 1): - for some_element in some_list: // таким
   образом будет куда сложнее выстрелить себе в ногу.

3) for i in range(len(some_list) - 5 - 1): - for some_element in some_list[:-5] //
   рефакторинг оставляет меньше возможностей для ошибки, он по- прежнему
   дурацкий из- за магического числа, но посыл именно тот, который я хотел
   продемонстрировать

4) Процедура вставки элемиентов в массив является крайне не эффективной. Поэтому
   такое применение массивов следует считать ошибочным. Но раз стоит такая
   задача- вставлять по индексу, стоит рассмотреть возможность применения
   односвязного списка. Это ускорит код.

5) some_list[len(some_list) - 1 - 1] - some_list[-1] // Python предоставляет
   отличный инструмент для работы с массивами- срезы. Применение срезов может
   помочь, если не обойтись без произвольной индексации. В данном случае
   применение среза смотрится оптимальным решением
