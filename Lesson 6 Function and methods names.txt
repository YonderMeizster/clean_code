1) Имена методов должны представлять из себя глаголы или глагольные
словосочетания. Методы чтения/ записи, а также условий образуются с
помощью префиксов get, set, is.

2) Имя метода должно прямо описывать, что он делает. В имя метода
полезно заключать также и выходные данные.

3) Имена процедур (методов, не возвращающих результат) строятся из
действия + объекта, над которым действие выполняется.

1. get(condition) - get_matching_nodes(condition) - имя метода расширено
информацией о том, что он делает.

2. sort(sequence, sort_key) - sort_by_key(sequence, sort_key) - имя
метода расширено информацией о том, что сортировка выполняется не абы
как, а по ключу сортировки. Из самого названия метода не ясно, что за
key. Но благодаря сигнатуре видно, что key- это ключ сортировки. А
разработчик, знакомый с python наверняка помнит о том, что что- то про
ключ сортировки, которые принимают в себя некоторые методы стандартной
библиотеки.

3. file_size(file) - get_file_size(file) - рефакторинг метода позволил
прояснить, что именно делает метод. Метод с названием "размер файла",
может делать почти все, что угодно, например, проверять, что у файла
вообще есть размер.

4. empty(sequence) - is_empty(sequence) - оригинальное название не дает
понять, что делает метод, вдруг удаляет все элементы? А новое название
задает вопрос, пуста ли последовательность. В результате код становится
более человеческим и его проще читать.

5. get_recieved(connection) - get_recieved_or_None(connection) -
рефакторинг имени метода позволил предупредить программистов о том,
что метод может вернуть и None, а это означает, что возможное исключение
при попытке обращения к данным может привести к исключению.

6. self.has(self, value) - self.has_node_with_value(self, value) -
рефакторинг метода позволил показать, что метод прнимает не некий объект
Node, а значение, которое в Node содержится.

7. create_u(name) - create_user(name) - оригинальное название скрывало
за завесой тайны смысл буквы ю. Следование правилам хорошего кода и
здравому смыслу позволило избавиться от этого недостатка.

8. process(number1, number2) - get_minimal_both_divisor(number1, number2) -
оригинальное название не говорит вообще ничего о методе. Новое название
сразу дает понять о том, что метод возвращает минимальный общий
делитель.

9. header(http_package) - get_header(http_package) - новое название куда
прозрачнее намекает на то, что метод вытаскивает заголовок из http
пакета.

10. send_data_via_connection(self, data) - send(self, data) - в данном
случае я продемонстрировал пример перегруженного именования метода.
Метод send является методом объекта, который в свою очередь является
экземпляром класса, представляющего некое соединения. По этой причине
такого короткого имени достаточно для того, чтобы читающий понял суть
метода: взять data и отправить в соединение

11. who_wins(first_player, second_player) - first_player_wins(first_player, second_player) -
оригинальное название лаконично хорошо выглядит, но совсем не ясно, а
что оно вернет? Ник игрока? Может ссылку на объект- игрока, и так далее.
Новое название принуждает возвращать true или false, и это может быть
полезно. В случае, если изменение типа возвращаемого объекта принуждает
перелапачивать слишком много кода, можно поступить иначе:
get_player_who_wins(first_player, second_player). Это название прямо
говорит, что возвращается ссылка на объект- игрока.

12. get_substrings(string) - get_list_of_all_substrings_of_string(string) -
оригинальное название говорит о методе слишком мало. Новое название
указывает на то, что вернется список строк, а все эти строки будут
являться подстроками строки, причем всеми возможными.
